<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Item — AI Pipeline Demo</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body { margin:0; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
           font-size:14px; background:#0f1117; color:#e2e8f0; line-height:1.6; }
    a { color:#63b3ed; text-decoration:none; }
    a:hover { text-decoration:underline; }

    /* -- Top bar -- */
    .topbar { background:#141720; border-bottom:1px solid #2d3748; padding:10px 20px;
              display:flex; align-items:center; gap:12px; font-size:13px;
              position:sticky; top:0; z-index:20; }
    .topbar .title { color:#e2e8f0; font-weight:600; flex:1; overflow:hidden;
                     text-overflow:ellipsis; white-space:nowrap; }
    .topbar .sep { color:#2d3748; }
    .topbar .provenance { font-size:11px; color:#4a5568; white-space:nowrap; }
    .topbar .provenance a { color:#4a5568; }
    .topbar .provenance a:hover { color:#63b3ed; }

    /* -- Page -- */
    .page { max-width:1400px; margin:0 auto; padding:24px 20px 80px; }

    /* -- Pipeline track -- */
    .pipeline-track { display:flex; flex-wrap:wrap; align-items:center; gap:0; row-gap:6px;
                      margin-bottom:28px; padding:12px 16px; background:#141720;
                      border:1px solid #2d3748; border-radius:8px; }
    .track-step { display:flex; align-items:center; }
    .track-label { font-size:12px; font-family:monospace; padding:4px 10px; border-radius:5px;
                   background:#2d3748; color:#a0aec0; cursor:pointer; transition:background .12s;
                   white-space:nowrap; }
    .track-label:hover  { background:#3a4a63; color:#e2e8f0; }
    .track-label.done   { background:#1c4532; color:#9ae6b4; border:1px solid #276749; }
    .track-label.failed { background:#3b1515; color:#fed7d7; border:1px solid #742a2a; }
    .track-arrow { font-size:20px; font-weight:700; line-height:1; color:#718096;
                   padding:0 2px; user-select:none; }
    .track-arrow.done { color:#48bb78; }

    /* -- Magnifier (images) -- */
    .magnifier-wrap {
      position:relative; width:100%; margin-bottom:28px;
      border:1px solid #2d3748; border-radius:8px; overflow:hidden;
      background:#141720; cursor:crosshair;
      max-height:520px;
    }
    .magnifier-wrap img.hero {
      width:100%; max-height:520px; object-fit:contain; display:block;
    }
    .mag-lens {
      position:absolute; width:200px; height:200px;
      border:2px solid #4299e1; border-radius:4px;
      pointer-events:none; display:none;
      overflow:hidden; box-shadow:0 0 0 1px #1a365d,0 4px 24px #000a;
    }
    .mag-lens img { position:absolute; }
    .mag-hint {
      position:absolute; bottom:8px; right:10px;
      font-size:11px; color:#4a5568; pointer-events:none;
    }

    /* -- PDF page viewer: image + OCR side by side -- */
    .pdf-page {
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:0;
      margin-bottom:24px;
      border:1px solid #2d3748;
      border-radius:8px;
      overflow:hidden;
      background:#141720;
    }
    @media (max-width:800px) {
      .pdf-page { grid-template-columns:1fr; }
    }
    .pdf-page-img-col {
      border-right:1px solid #2d3748;
      background:#0f1117;
      display:flex;
      flex-direction:column;
      position:relative;
      cursor:crosshair;
    }
    @media (max-width:800px) {
      .pdf-page-img-col { border-right:none; border-bottom:1px solid #2d3748; }
    }
    .pdf-page-img-col img.page-hero {
      width:100%;
      display:block;
    }
    .pdf-page-img-col .mag-lens {
      position:absolute; width:220px; height:220px;
      border:2px solid #4299e1; border-radius:4px;
      pointer-events:none; display:none;
      overflow:hidden; box-shadow:0 0 0 1px #1a365d,0 4px 24px #000a;
      z-index:10;
    }
    .pdf-page-img-col .mag-lens img { position:absolute; }
    .pdf-page-img-col .mag-hint {
      position:absolute; bottom:6px; right:8px;
      font-size:10px; color:#4a5568; pointer-events:none;
    }
    .pdf-page-ocr-col {
      padding:16px 18px;
      overflow-y:auto;
    }
    /* When proportional scaling is active, lock height to match the image */
    .pdf-page-ocr-col.scaled {
      overflow-y:hidden;
    }
    .pdf-page-heading {
      display:flex; align-items:center; gap:10px;
      padding:8px 14px;
      background:#1a1f2e;
      border-bottom:1px solid #2d3748;
      flex-wrap:wrap;
    }
    .pdf-page-num { font-weight:700; font-size:13px; color:#90cdf4; font-family:monospace; }
    .pdf-page-dim { font-size:11px; color:#4a5568; }
    .pdf-page-summary {
      width:100%;
      font-size:12px;
      color:#718096;
      line-height:1.5;
      margin-top:4px;
    }
    .pdf-page-summary strong { color:#a0aec0; }

    /* Toggle button for proportional scaling */
    .scale-toggle {
      margin-left:auto;
      font-size:11px;
      padding:2px 10px;
      border-radius:4px;
      border:1px solid #2d3748;
      background:#141720;
      color:#718096;
      cursor:pointer;
      white-space:nowrap;
    }
    .scale-toggle:hover { border-color:#4299e1; color:#e2e8f0; }
    .scale-toggle.active { border-color:#4299e1; color:#90cdf4; background:#1a2332; }

    .ocr-text {
      font-size:16px; color:#a0aec0; line-height:1.8;
      white-space:pre-wrap; word-break:break-word;
    }
    .ocr-text h1,.ocr-text h2,.ocr-text h3 { color:#e2e8f0; margin:0 0 6px; }

    /* Handwritten text annotation */
    .hw {
      color:#f6e05e;
      font-style:italic;
      font-weight:600;
      border-bottom:1px dotted #d69e2e44;
    }
    /* Low-confidence marker */
    .uncertain {
      color:#fc8181;
      font-size:10px;
      font-weight:700;
      vertical-align:super;
      cursor:help;
      margin-left:1px;
    }

    /* -- OCR layout blocks -- */
    .ocr-blocks { display:flex; flex-direction:column; gap:10px; }
    .block-card {
      border-radius:6px; padding:10px 14px;
      border-left:3px solid #2d3748;
    }
    .block-card.headline    { border-color:#90cdf4; background:#0d1a2e; }
    .block-card.subheadline { border-color:#63b3ed; background:#0a1628; }
    .block-card.byline      { border-color:#718096; background:#141720; font-style:italic; font-size:12px; color:#a0aec0; }
    .block-card.dateline    { border-color:#718096; background:#141720; font-style:italic; font-size:12px; color:#a0aec0; }
    .block-card.caption     { border-color:#68d391; background:#0a1a12; font-size:12px; color:#9ae6b4; }
    .block-card.paragraph,
    .block-card.column      { border-color:#2d3748; background:#141720; font-size:13px; }
    .block-card.advertisement { border-color:#d69e2e; background:#1a1400; font-size:12px; color:#fbd38d; }
    .block-card.other       { border-color:#2d3748; background:#141720; font-size:12px; color:#718096; }

    .block-type-label { font-size:10px; text-transform:uppercase; letter-spacing:.06em;
                        color:#4a5568; margin-bottom:4px; }
    .block-headline-text  { font-size:16px; font-weight:700; color:#e2e8f0; line-height:1.3; }
    .block-sub-text       { font-size:13px; font-weight:600; color:#cbd5e0; line-height:1.4; }
    .block-body-text      { font-size:13px; color:#a0aec0; line-height:1.7; }

    /* Image blocks from Mistral OCR */
    .image-blocks { display:flex; flex-wrap:wrap; gap:12px; margin-top:12px; }
    .image-block-card {
      border:1px solid #2d3748; border-radius:6px; overflow:hidden;
      background:#1a1f2e; max-width:300px;
    }
    .image-block-card img { width:100%; display:block; }
    .image-block-caption { padding:5px 10px; font-size:11px; color:#718096; }

    /* -- Task sections -- */
    .task-section { margin-bottom:36px; scroll-margin-top:56px; }
    .task-header { display:flex; align-items:baseline; gap:10px; margin-bottom:12px;
                   padding-bottom:8px; border-bottom:1px solid #2d3748; }
    .task-name { font-family:monospace; font-size:16px; font-weight:700; color:#90cdf4; }
    .task-badge { font-size:11px; padding:1px 8px; border-radius:999px; }
    .badge-done   { background:#1c4532; color:#9ae6b4; border:1px solid #276749; }
    .badge-failed { background:#3b1515; color:#fed7d7; border:1px solid #742a2a; }

    /* -- Token pill -- */
    .token-pill { display:inline-flex; gap:14px; background:#1a1f2e; border:1px solid #2d3748;
                  border-radius:6px; padding:3px 12px; font-size:11px; color:#718096; margin-bottom:12px; }
    .token-pill strong { color:#a0aec0; }

    /* -- Generic fields -- */
    .fields { display:flex; flex-direction:column; gap:12px; }
    .field-label { font-size:11px; color:#718096; text-transform:uppercase; letter-spacing:.05em; margin-bottom:3px; }
    .field-value { background:#1a1f2e; border:1px solid #2d3748; border-radius:6px;
                   padding:10px 14px; white-space:pre-wrap; word-break:break-word;
                   line-height:1.7; font-size:13px; }
    .chips { display:flex; flex-wrap:wrap; gap:5px; }
    .chip  { background:#2d3748; border-radius:4px; padding:2px 9px; font-size:12px; color:#e2e8f0; }

    /* -- Raw JSON -- */
    details { margin-top:10px; }
    details summary { cursor:pointer; color:#63b3ed; font-size:12px; user-select:none; }
    pre { background:#141720; border:1px solid #2d3748; border-radius:6px;
          padding:12px 14px; font-size:11px; color:#a0aec0;
          overflow-x:auto; white-space:pre-wrap; word-break:break-word;
          margin:8px 0 0; max-height:400px; }

    /* -- Error / loading -- */
    .error-box { background:#3b151522; border:1px solid #742a2a; border-radius:6px;
                 padding:12px 16px; color:#fed7d7; }
    #loading { text-align:center; padding:80px; color:#4a5568; }
  </style>
</head>
<body>

<div class="topbar">
  <a href="index.html">&larr; Gallery</a>
  <span class="sep">|</span>
  <span class="title" id="topTitle">Loading...</span>
</div>

<div id="loading">Loading...</div>

<div class="page" id="page" style="display:none">
  <!-- Magnifier image viewer (for non-PDF items) -->
  <div class="magnifier-wrap" id="magWrap" style="display:none">
    <img id="heroImg" class="hero" src="" alt="" />
    <div class="mag-lens" id="magLens">
      <img id="magLensImg" src="" alt="" />
    </div>
    <span class="mag-hint">Hover to magnify</span>
  </div>

  <!-- PDF page-by-page viewer -->
  <div id="pdfPages" style="display:none"></div>

  <div class="pipeline-track" id="pipelineTrack"></div>
  <div id="taskSections"></div>
</div>

<script type="module">
// -- Utils -------------------------------------------------------------------
async function sha1hex(str) {
  const buf  = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest('SHA-1', buf);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
}
const esc = s => String(s??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
const isImg = url => /\.(jpe?g|png|gif|webp|avif)(\?.*)?$/i.test(url) || url.includes('/iiif/');
const isPdf = url => /\.pdf(\?.*)?$/i.test(url);

/** Minimal markdown -> HTML (headings, bold, italic, line breaks). */
function mdToHtml(md) {
  return esc(md)
    .split('\n')
    .map(line => {
      // Headings
      if (line.startsWith('### ')) return `<h3>${line.slice(4)}</h3>`;
      if (line.startsWith('## '))  return `<h2>${line.slice(3)}</h2>`;
      if (line.startsWith('# '))   return `<h1>${line.slice(2)}</h1>`;
      // Bold and italic
      line = line.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
      line = line.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      line = line.replace(/\*(.+?)\*/g, '<em>$1</em>');
      return line;
    })
    .join('\n');
}

// -- Magnifier ---------------------------------------------------------------
function initMagnifier(wrap, hero, lens, lensImg, zoom=4) {
  const lensW = lens.offsetWidth  || 200;
  const lensH = lens.offsetHeight || 200;

  wrap.addEventListener('mouseenter', () => { lens.style.display='block'; });
  wrap.addEventListener('mouseleave', () => { lens.style.display='none'; });

  wrap.addEventListener('mousemove', e => {
    const rect   = wrap.getBoundingClientRect();
    const heroRect = hero.getBoundingClientRect();
    const cx = e.clientX - heroRect.left;
    const cy = e.clientY - heroRect.top;

    let lx = e.clientX - rect.left - lensW/2;
    let ly = e.clientY - rect.top  - lensH/2;
    lx = Math.max(0, Math.min(rect.width  - lensW, lx));
    ly = Math.max(0, Math.min(rect.height - lensH, ly));
    lens.style.left = lx + 'px';
    lens.style.top  = ly + 'px';

    const imgW = hero.clientWidth  * zoom;
    const imgH = hero.clientHeight * zoom;
    const imgLeft = -(cx * zoom - lensW/2);
    const imgTop  = -(cy * zoom - lensH/2);

    lensImg.style.width  = imgW  + 'px';
    lensImg.style.height = imgH  + 'px';
    lensImg.style.left   = imgLeft + 'px';
    lensImg.style.top    = imgTop  + 'px';
  });
}

// -- Annotated text rendering ------------------------------------------------
/**
 * Convert annotated text with <hw>...</hw> and <?> markers into styled HTML.
 * Escapes all other HTML, then replaces our markers with styled spans.
 */
function renderAnnotatedText(text) {
  // Escape HTML but preserve our markers by using placeholders
  const HW_OPEN  = '\x00HW_OPEN\x00';
  const HW_CLOSE = '\x00HW_CLOSE\x00';
  const UNCERTAIN = '\x00UNCERTAIN\x00';

  let s = text
    .replace(/<hw>/gi, HW_OPEN)
    .replace(/<\/hw>/gi, HW_CLOSE)
    .replace(/<\?>/g, UNCERTAIN);

  // Escape remaining HTML
  s = s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');

  // Replace placeholders with styled markup
  s = s
    .replace(new RegExp(HW_OPEN.replace(/\x00/g, '\\x00'), 'g'), '<span class="hw">')
    .replace(new RegExp(HW_CLOSE.replace(/\x00/g, '\\x00'), 'g'), '</span>')
    .replace(new RegExp(UNCERTAIN.replace(/\x00/g, '\\x00'), 'g'), '<span class="uncertain" title="Low confidence">?</span>');

  return s;
}

// -- PDF page image path -----------------------------------------------------
/** Uses SHA1 hash of the URL as prefix: images/pages/{sha1}-{pagenum}.jpg */
function pageImgSrc(sha1, pageIndex, totalPages) {
  const digits = totalPages > 99 ? 3 : totalPages > 9 ? 2 : 1;
  const num = String(pageIndex + 1).padStart(digits, '0');
  return `images/pages/${sha1}-${num}.jpg`;
}

// -- PDF page-by-page renderer -----------------------------------------------
/**
 * Proportional scaling: adjust OCR font-size & line-height so the text
 * column fills the same vertical space as the page image beside it.
 */
function applyProportionalScale(imgEl, ocrCol) {
  const imgH = imgEl.clientHeight;
  if (!imgH) return;

  const textEl = ocrCol.querySelector('.ocr-text') ?? ocrCol.querySelector('.ocr-blocks');
  if (!textEl) return;

  // Count visible lines (newlines in the text content)
  const text = textEl.textContent ?? '';
  const lines = text.split('\n').filter(l => l.trim().length > 0);
  const lineCount = Math.max(lines.length, 1);

  // Target: fill imgH pixels with lineCount lines
  // lineHeight = imgH / lineCount, fontSize ~ lineHeight * 0.55
  const targetLineH = imgH / lineCount;
  const fontSize = Math.max(10, Math.min(28, targetLineH * 0.55));
  const lineHeight = targetLineH;

  ocrCol.classList.add('scaled');
  ocrCol.style.height = imgH + 'px';
  ocrCol.style.padding = '8px 14px';
  textEl.style.fontSize = fontSize + 'px';
  textEl.style.lineHeight = lineHeight + 'px';
}

function removeProportionalScale(ocrCol) {
  const textEl = ocrCol.querySelector('.ocr-text') ?? ocrCol.querySelector('.ocr-blocks');
  ocrCol.classList.remove('scaled');
  ocrCol.style.height = '';
  ocrCol.style.padding = '';
  if (textEl) {
    textEl.style.fontSize = '';
    textEl.style.lineHeight = '';
  }
}

function renderPdfPages(pdfUrl, sha1, ocrResult, annotateResult, allResults) {
  const container = document.getElementById('pdfPages');
  container.style.display = 'block';

  const pages = ocrResult?.pages ?? [];
  if (!pages.length) {
    container.innerHTML = '<p style="color:#4a5568;padding:20px">No OCR page data available.</p>';
    return;
  }

  const layoutBlocks = ocrResult?.layout_blocks ?? [];
  const imageBlocks  = ocrResult?.image_blocks ?? [];

  // Build a lookup of annotated text by page index
  const annotatedByPage = {};
  if (annotateResult?.pages) {
    for (const ap of annotateResult.pages) {
      annotatedByPage[ap.index] = ap.annotated_text ?? '';
    }
  }

  // Collect all scale-toggle pairs for the global toggle
  const scalePairs = [];
  let scalingOn = false;

  // -- Global toggle at top --
  const globalBar = document.createElement('div');
  globalBar.style.cssText = 'display:flex;align-items:center;gap:12px;margin-bottom:16px;padding:8px 14px;background:#141720;border:1px solid #2d3748;border-radius:8px';
  const globalToggle = document.createElement('button');
  globalToggle.className = 'scale-toggle';
  globalToggle.textContent = 'Align text to image';
  globalToggle.title = 'Scale OCR text so lines roughly match the page image height';
  globalBar.appendChild(globalToggle);

  const legendEl = document.createElement('span');
  legendEl.style.cssText = 'font-size:11px;color:#4a5568';
  legendEl.innerHTML = '<span class="hw">Yellow italic</span> = handwritten &nbsp; <span class="uncertain" title="Low confidence">?</span> = uncertain';
  globalBar.appendChild(legendEl);

  container.appendChild(globalBar);

  for (const page of pages) {
    const pi = page.index ?? 0;
    const md = (page.markdown ?? '').trim();
    const annotatedText = (annotatedByPage[pi] ?? '').trim();

    // Skip blank pages
    const hasText   = md.length > 10 || annotatedText.length > 10;
    const hasBlocks = layoutBlocks.some(b => (b.page ?? 0) === pi && b.text?.trim());
    if (!hasText && !hasBlocks) continue;

    const section = document.createElement('div');
    section.className = 'pdf-page';

    // -- Heading (spans both columns) --
    const heading = document.createElement('div');
    heading.className = 'pdf-page-heading';
    heading.style.gridColumn = '1 / -1';
    const dim = page.dimensions ? `${page.dimensions.width}x${page.dimensions.height}` : '';
    heading.innerHTML = `<span class="pdf-page-num">Page ${pi + 1}</span>${dim ? `<span class="pdf-page-dim">${esc(dim)}</span>` : ''}`;

    // Page-level summary from AI results if available
    const summary = allResults?.['summarize']?.pages?.[pi]?.summary
                 ?? allResults?.['summarize']?.summary;  // fall back to doc-level
    const title   = allResults?.['generate_title']?.pages?.[pi]?.title;
    if (title || (summary && pages.length <= 10)) {
      const sumEl = document.createElement('div');
      sumEl.className = 'pdf-page-summary';
      let html = '';
      if (title) html += `<strong>${esc(title)}</strong> `;
      if (summary && pages.length <= 10) html += esc(summary.slice(0, 200));
      sumEl.innerHTML = html;
      heading.appendChild(sumEl);
    }

    section.appendChild(heading);

    // -- Left: page image with magnifier --
    const imgCol = document.createElement('div');
    imgCol.className = 'pdf-page-img-col';
    const imgSrc = pageImgSrc(sha1, pi, pages.length);
    const lensId = `mag-lens-${pi}`;
    const lensImgId = `mag-lens-img-${pi}`;
    const heroId = `page-hero-${pi}`;
    imgCol.innerHTML = `<img id="${heroId}" class="page-hero" src="${esc(imgSrc)}" alt="Page ${pi+1}" loading="lazy"
      onerror="this.outerHTML='<div style=\\'padding:40px;color:#4a5568;text-align:center\\'>Page image not available</div>'" />
      <div class="mag-lens" id="${lensId}"><img id="${lensImgId}" src="${esc(imgSrc)}" alt="" /></div>
      <span class="mag-hint">Hover to magnify</span>`;
    section.appendChild(imgCol);

    // -- Right: OCR text (prefer annotated if available) --
    const ocrCol = document.createElement('div');
    ocrCol.className = 'pdf-page-ocr-col';
    const ocrColId = `ocr-col-${pi}`;
    ocrCol.id = ocrColId;

    if (annotatedText) {
      const prose = document.createElement('div');
      prose.className = 'ocr-text';
      prose.innerHTML = renderAnnotatedText(annotatedText);
      ocrCol.appendChild(prose);
    } else {
      const pageBlocks = layoutBlocks.filter(b => (b.page ?? 0) === pi && b.type !== 'image' && b.text?.trim());
      if (pageBlocks.length) {
        const blocksEl = document.createElement('div');
        blocksEl.className = 'ocr-blocks';
        const sorted = [...pageBlocks].sort((a,b) => (a.bbox?.y??0) - (b.bbox?.y??0));
        for (const block of sorted) {
          const card = document.createElement('div');
          card.className = `block-card ${block.type}`;
          let textHtml;
          if (block.type === 'headline')         textHtml = `<div class="block-headline-text">${esc(block.text)}</div>`;
          else if (block.type === 'subheadline') textHtml = `<div class="block-sub-text">${esc(block.text)}</div>`;
          else                                   textHtml = `<div class="block-body-text">${esc(block.text)}</div>`;
          card.innerHTML = textHtml;
          blocksEl.appendChild(card);
        }
        ocrCol.appendChild(blocksEl);
      } else if (hasText) {
        const prose = document.createElement('div');
        prose.className = 'ocr-text';
        prose.innerHTML = mdToHtml(md);
        ocrCol.appendChild(prose);
      }
    }

    section.appendChild(ocrCol);
    container.appendChild(section);

    // Wire up magnifier + collect scale pairs
    const heroEl = document.getElementById(heroId);
    const lensEl = document.getElementById(lensId);
    const lensImgEl = document.getElementById(lensImgId);

    if (heroEl && lensEl && lensImgEl) {
      const initPage = () => {
        initMagnifier(imgCol, heroEl, lensEl, lensImgEl, 3);
        scalePairs.push({ imgEl: heroEl, ocrCol });
        if (scalingOn) applyProportionalScale(heroEl, ocrCol);
      };
      heroEl.addEventListener('load', initPage);
      if (heroEl.complete && heroEl.naturalWidth > 0) initPage();
    }
  }

  // Wire global toggle
  globalToggle.addEventListener('click', () => {
    scalingOn = !scalingOn;
    globalToggle.classList.toggle('active', scalingOn);
    globalToggle.textContent = scalingOn ? 'Normal text size' : 'Align text to image';
    for (const { imgEl, ocrCol } of scalePairs) {
      if (scalingOn) {
        applyProportionalScale(imgEl, ocrCol);
      } else {
        removeProportionalScale(ocrCol);
      }
    }
  });
}

// -- OCR rendering for single images (unchanged) ----------------------------
const BLOCK_RANK = {headline:0, subheadline:1, byline:2, dateline:2,
                    column:3, paragraph:3, caption:4, image:5, advertisement:6, other:7};

function renderBlocksForPage(layoutBlocks, imageBlocks, pageIndex) {
  const frag = document.createDocumentFragment();
  const pageBlocks = (layoutBlocks ?? []).filter(b => (b.page ?? 0) === pageIndex);
  if (pageBlocks.length) {
    const blocksEl = document.createElement('div');
    blocksEl.className = 'ocr-blocks';
    const sorted = [...pageBlocks].sort((a,b) => (a.bbox?.y??0) - (b.bbox?.y??0));
    for (const block of sorted) {
      if (block.type === 'image' || !block.text?.trim()) continue;
      const card = document.createElement('div');
      card.className = `block-card ${block.type}`;
      let textHtml;
      if (block.type === 'headline') {
        textHtml = `<div class="block-headline-text">${esc(block.text)}</div>`;
      } else if (block.type === 'subheadline') {
        textHtml = `<div class="block-sub-text">${esc(block.text)}</div>`;
      } else {
        textHtml = `<div class="block-body-text">${esc(block.text)}</div>`;
      }
      card.innerHTML = textHtml;
      blocksEl.appendChild(card);
    }
    frag.appendChild(blocksEl);
  }

  const pageImgs = (imageBlocks ?? []).filter(b => (b.page ?? 0) === pageIndex && b.image_base64);
  if (pageImgs.length) {
    const imgWrap = document.createElement('div');
    imgWrap.className = 'image-blocks';
    for (const img of pageImgs) {
      const card = document.createElement('div');
      card.className = 'image-block-card';
      const w = img.bottom_right_x - img.top_left_x;
      const h = img.bottom_right_y - img.top_left_y;
      card.innerHTML = `
        <img src="${img.image_base64}" alt="${esc(img.id)}" />
        <div class="image-block-caption">
          ${esc(img.id)}${img.annotation ? ` — ${esc(img.annotation)}` : ''}
          <span style="float:right;color:#4a5568">${w}x${h}px</span>
        </div>`;
      imgWrap.appendChild(card);
    }
    frag.appendChild(imgWrap);
  }

  return frag;
}

function renderLayoutBlocks(layoutBlocks, imageBlocks, pages) {
  const wrap = document.createElement('div');

  if (pages?.length > 1) {
    for (const page of pages) {
      const pi  = page.index ?? 0;
      const md  = (page.markdown ?? '').trim();
      const hasText   = md.length > 10;
      const hasBlocks = (layoutBlocks ?? []).some(b => (b.page ?? 0) === pi && b.text?.trim());
      const hasImgs   = (imageBlocks  ?? []).some(b => (b.page ?? 0) === pi);
      if (!hasText && !hasBlocks && !hasImgs) continue;

      const section = document.createElement('div');
      section.className = 'page-section';
      section.style.cssText = 'margin-bottom:28px;border:1px solid #2d3748;border-radius:8px;overflow:hidden';

      const heading = document.createElement('div');
      heading.style.cssText = 'display:flex;align-items:center;gap:12px;padding:8px 14px;background:#141720;border-bottom:1px solid #2d3748';
      const dim = page.dimensions ? `${page.dimensions.width}x${page.dimensions.height}px` : '';
      heading.innerHTML = `<span style="font-weight:700;font-size:13px;color:#90cdf4;font-family:monospace">Page ${pi + 1}</span>${dim ? `<span style="font-size:11px;color:#4a5568">${esc(dim)}</span>` : ''}`;
      section.appendChild(heading);

      const pageBlocks = (layoutBlocks ?? []).filter(b => (b.page ?? 0) === pi && b.type !== 'image' && b.text?.trim());

      const body = document.createElement('div');
      body.style.cssText = `display:grid;grid-template-columns:${pageBlocks.length ? '1fr 1fr' : '1fr'};gap:0`;

      if (pageBlocks.length) {
        const leftCol = document.createElement('div');
        leftCol.style.cssText = 'padding:14px';
        leftCol.innerHTML = `<div style="font-size:10px;text-transform:uppercase;letter-spacing:.07em;color:#4a5568;margin-bottom:10px">Layout blocks</div>`;
        const blocksEl = document.createElement('div');
        blocksEl.className = 'ocr-blocks';
        const sorted = [...pageBlocks].sort((a,b) => (a.bbox?.y??0) - (b.bbox?.y??0));
        for (const block of sorted) {
          const card = document.createElement('div');
          card.className = `block-card ${block.type}`;
          const typeLabel = `<div class="block-type-label">${esc(block.type)}</div>`;
          let textHtml;
          if (block.type === 'headline')         textHtml = `<div class="block-headline-text">${esc(block.text)}</div>`;
          else if (block.type === 'subheadline') textHtml = `<div class="block-sub-text">${esc(block.text)}</div>`;
          else                                   textHtml = `<div class="block-body-text">${esc(block.text)}</div>`;
          card.innerHTML = typeLabel + textHtml;
          blocksEl.appendChild(card);
        }
        leftCol.appendChild(blocksEl);
        body.appendChild(leftCol);
      }

      if (hasText) {
        const rightCol = document.createElement('div');
        rightCol.style.cssText = `padding:14px;${pageBlocks.length ? 'border-left:1px solid #2d3748' : ''}`;
        rightCol.innerHTML = `<div style="font-size:10px;text-transform:uppercase;letter-spacing:.07em;color:#4a5568;margin-bottom:10px">${pageBlocks.length ? 'Markdown (OCR text)' : 'OCR text'}</div>
          <div class="ocr-text">${esc(md)}</div>`;
        body.appendChild(rightCol);
      }

      section.appendChild(body);
      wrap.appendChild(section);
    }
    return wrap;
  }

  wrap.appendChild(renderBlocksForPage(layoutBlocks, imageBlocks, 0));
  return wrap;
}

// -- Field rendering ---------------------------------------------------------
const FIELD_ORDER = ['title','alternativeTitles','type','subtype','rationale',
  'summary','description','text','transcription','language','confidence',
  'dateRange','people','places','organisations','subjects','names','dates',
  'keywords','physicalAttributes','safety','notes','translation'];

function renderField(key, val) {
  if (val==null||val===''||(Array.isArray(val)&&!val.length)) return '';
  const label = `<div class="field-label">${esc(key)}</div>`;
  if (Array.isArray(val)) {
    const chips = val.map(v=>`<span class="chip">${esc(typeof v==='object'?JSON.stringify(v):v)}</span>`).join('');
    return `<div>${label}<div class="chips">${chips}</div></div>`;
  }
  if (typeof val==='object') {
    return `<div>${label}<div class="field-value" style="font-size:11px">${esc(JSON.stringify(val,null,2))}</div></div>`;
  }
  return `<div>${label}<div class="field-value">${esc(String(val))}</div></div>`;
}

function renderTaskResult(taskName, result, imageUrl, isPdfItem) {
  const el = document.createElement('div');
  el.className = 'task-section';
  el.id = `task-${taskName}`;

  const failed = result.error || result.failed;
  const badge  = failed
    ? `<span class="task-badge badge-failed">failed</span>`
    : `<span class="task-badge badge-done">done</span>`;

  const header = `<div class="task-header"><span class="task-name">${esc(taskName)}</span>${badge}</div>`;

  if (failed) {
    el.innerHTML = header + `<div class="error-box">${esc(result.error??'Unknown error')}</div>`;
    return el;
  }

  let tokensHtml = '';
  if (result._tokens) {
    const t = result._tokens;
    tokensHtml = `<div class="token-pill">
      <span>prompt <strong>${t.prompt?.toLocaleString()}</strong></span>
      <span>completion <strong>${t.completion?.toLocaleString()}</strong></span>
      <span>total <strong>${t.total?.toLocaleString()}</strong></span>
      ${t.cached?`<span>cached <strong>${t.cached.toLocaleString()}</strong></span>`:''}
    </div>`;
  }

  el.innerHTML = header + tokensHtml;

  // annotate_handwriting: render with styled markers
  if (taskName === 'annotate_handwriting' && result.annotated_text) {
    const prose = document.createElement('div');
    prose.className = 'ocr-text';
    prose.innerHTML = renderAnnotatedText(result.annotated_text);
    el.appendChild(prose);

    const legend = document.createElement('div');
    legend.style.cssText = 'margin-top:12px;font-size:11px;color:#4a5568';
    legend.innerHTML = '<span class="hw">Yellow italic = handwritten</span> &nbsp; <span class="uncertain" title="Low confidence">?</span> = uncertain word';
    el.appendChild(legend);

    const stripped = Object.fromEntries(Object.entries(result).filter(([k])=>k!=='_tokens'&&k!=='image_blocks'));
    const details = document.createElement('details');
    details.innerHTML = `<summary>Raw JSON</summary><pre>${esc(JSON.stringify(stripped,null,2))}</pre>`;
    el.appendChild(details);
    return el;
  }

  // For PDFs, ocr_mistral is rendered page-by-page above; show summary here
  if (taskName === 'ocr_mistral' && isPdfItem) {
    const pageCount = result.pages?.length ?? 0;
    const summary = document.createElement('div');
    summary.className = 'field-value';
    summary.textContent = `${pageCount} page(s) processed. See page-by-page view above.`;
    el.appendChild(summary);
  } else if (taskName === 'ocr_mistral') {
    el.appendChild(renderLayoutBlocks(result.layout_blocks, result.image_blocks, result.pages));
  } else {
    const fields = document.createElement('div');
    fields.className = 'fields';
    const seen = new Set(['_tokens','raw_response','blocks','layout_blocks','image_blocks','pages','error','failed','skipped']);
    for (const key of FIELD_ORDER) {
      if (result[key]==null) continue;
      seen.add(key);
      fields.innerHTML += renderField(key, result[key]);
    }
    for (const [key,val] of Object.entries(result)) {
      if (!seen.has(key)) fields.innerHTML += renderField(key, val);
    }
    el.appendChild(fields);
  }

  const stripped = Object.fromEntries(Object.entries(result).filter(([k])=>k!=='_tokens'&&k!=='image_blocks'));
  const details = document.createElement('details');
  details.innerHTML = `<summary>Raw JSON</summary><pre>${esc(JSON.stringify(stripped,null,2))}</pre>`;
  el.appendChild(details);
  return el;
}

// -- Main --------------------------------------------------------------------
async function main() {
  const params   = new URL(location.href).searchParams;
  const subject  = params.get('url');
  const dataDir  = params.get('data') ?? 'data';
  const itemType = params.get('type') ?? (isPdf(subject??'') ? 'pdf' : 'image');

  if (!subject) {
    document.getElementById('loading').innerHTML =
      '<p>No <code>?url=</code> parameter. <a href="index.html">&larr; Gallery</a></p>';
    return;
  }

  // Load manifest for title + pipeline order
  // Try the type-specific manifest first, then fall back
  const manifestFiles = itemType === 'pdf'
    ? ['pdfs.json', 'images.json']
    : ['images.json', 'pdfs.json'];

  let entry = null;
  for (const mf of manifestFiles) {
    try {
      const r = await fetch(`${dataDir}/${mf}`);
      if (r.ok) {
        const all = await r.json();
        entry = all.find(e => e.url === subject) ?? null;
        if (entry) break;
      }
    } catch(_) {}
  }

  // Load result file
  const hash = await sha1hex(subject);
  let data;
  try {
    const r = await fetch(`${dataDir}/${hash}.json`);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    data = await r.json();
  } catch(e) {
    document.getElementById('loading').innerHTML =
      `<p>Results not found.</p><p>${esc(e.message)}</p>
       <p>Run <code>bin/console app:process</code> first.</p>
       <p><a href="index.html">&larr; Gallery</a></p>`;
    return;
  }

  document.getElementById('loading').style.display = 'none';
  document.getElementById('page').style.display    = 'block';

  const title      = entry?.title ?? subject;
  const provenance = entry?.provenance ?? '';
  const pipeline   = entry?.pipeline ?? Object.keys(data.results??{});
  const results    = data.results ?? {};
  const isPdfItem  = isPdf(subject);

  document.title = title + ' — AI Pipeline Demo';
  document.getElementById('topTitle').textContent = title;

  // Show provenance link in topbar
  if (provenance) {
    const topbar = document.querySelector('.topbar');
    const provEl = document.createElement('span');
    provEl.className = 'provenance';
    try {
      const host = new URL(provenance).hostname;
      provEl.innerHTML = `<a href="${esc(provenance)}" target="_blank" title="Source collection">${esc(host)}</a>`;
    } catch(_) {
      provEl.innerHTML = `<a href="${esc(provenance)}" target="_blank">Source</a>`;
    }
    topbar.appendChild(provEl);
  }

  // -- Render viewer based on type --
  if (isPdfItem) {
    // PDF: render page images + OCR side by side
    const ocrResult = results['ocr_mistral'];
    const annotateResult = results['annotate_handwriting'];
    if (ocrResult && !ocrResult.error) {
      renderPdfPages(subject, hash, ocrResult, annotateResult, results);
    }
  } else if (isImg(subject)) {
    // Image: magnifier viewer
    const wrap    = document.getElementById('magWrap');
    const hero    = document.getElementById('heroImg');
    const lens    = document.getElementById('magLens');
    const lensImg = document.getElementById('magLensImg');
    hero.src      = subject;
    lensImg.src   = subject;
    wrap.style.display = 'block';
    hero.onload = () => initMagnifier(wrap, hero, lens, lensImg, 4);
  }

  // Pipeline track
  const track = document.getElementById('pipelineTrack');
  pipeline.forEach((taskName, i) => {
    const r   = results[taskName];
    const cls = !r ? '' : (r.error||r.failed) ? 'failed' : 'done';
    const btn = document.createElement('span');
    btn.className = 'track-step';
    btn.innerHTML = `<span class="track-label ${cls}" id="track-${taskName}"
        onclick="document.getElementById('task-${taskName}')?.scrollIntoView({behavior:'smooth'})"
      >${esc(taskName)}</span>${i<pipeline.length-1?`<span class="track-arrow ${cls}">&rarr;</span>`:''}`;
    track.appendChild(btn);
  });

  // Task sections in pipeline order
  const sectionsEl = document.getElementById('taskSections');
  const rendered   = new Set();
  for (const taskName of pipeline) {
    if (!results[taskName]) continue;
    sectionsEl.appendChild(renderTaskResult(taskName, results[taskName], subject, isPdfItem));
    rendered.add(taskName);
  }
  for (const [taskName,result] of Object.entries(results)) {
    if (!rendered.has(taskName))
      sectionsEl.appendChild(renderTaskResult(taskName, result, subject, isPdfItem));
  }
}

main();
</script>
</body>
</html>
